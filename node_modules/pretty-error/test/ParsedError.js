(function() {
  var ParsedError, chai, error;

  chai = require('chai');

  ParsedError = require('../src/ParsedError');

  chai.should();

  error = function(what) {
    var e;
    if (typeof what === 'string') {
      return error(function() {
        throw Error(what);
      });
    } else if (what instanceof Function) {
      try {
        what();
        return null;
      } catch (error1) {
        e = error1;
        return e;
      }
    } else {
      throw Error("bad argument for error");
    }
  };

  describe("ParsedError", function() {
    describe("constructor()", function() {
      it("should accept Error() instances", function() {
        return (function() {
          return new ParsedError(error(function() {
            throw Error("some message");
          }));
        }).should.not["throw"]();
      });
      it("should accept ReferenceError() and other derivatives of Error()", function() {
        return (function() {
          return new ParsedError(error(function() {
            throw ReferenceError("some message");
          }));
        }).should.not["throw"]();
      });
      return it("should accept non errors", function() {
        return (function() {
          var e;
          return e = new ParsedError('some string');
        }).should.not["throw"]();
      });
    });
    describe("message", function() {
      return it("should return the original error message", function() {
        var e;
        e = new ParsedError(error('a'));
        return e.message.should.equal('a');
      });
    });
    describe("kind", function() {
      it("should return 'Error' for normal error", function() {
        var e;
        e = new ParsedError(error('a'));
        return e.kind.should.equal('Error');
      });
      return it("should recognize 'ReferenceError'", function() {
        var e;
        e = new ParsedError(error(function() {
          return a.b = c;
        }));
        return e.kind.should.equal('ReferenceError');
      });
    });
    describe("type", function() {
      return it.skip("should return original error type", function() {
        var e;
        e = new ParsedError(error(function() {
          return a.b = c;
        }));
        return e.type.should.be.equal('not_defined');
      });
    });
    describe("arguments", function() {
      return it.skip("should return original error arguments", function() {
        var e;
        e = new ParsedError(error(function() {
          return a.b = c;
        }));
        return e["arguments"].should.be.eql(['a']);
      });
    });
    describe("stack", function() {
      return it("should return original error stack", function() {
        var e;
        e = new ParsedError(error(function() {
          return a.b = c;
        }));
        return e.stack.should.be.equal(e.error.stack);
      });
    });
    describe("trace", function() {
      return it("should include correct information about each trace item", function() {
        var e, item;
        e = new ParsedError(error(function() {
          return a.b = c;
        }));
        e.trace.should.have.length.above(2);
        item = e.trace[0];
        item.should.include.keys('original', 'what', 'path', 'addr', 'file', 'dir', 'col', 'line', 'jsCol', 'jsLine', 'packageName', 'shortenedPath', 'shortenedAddr');
        item.path.should.equal(module.filename.replace(/[\\]+/g, '/'));
        item.line.should.be.a('number');
        return item.col.should.be.a('number');
      });
    });
    return describe("_rectifyPath()", function() {
      it("should work", function() {
        return ParsedError.prototype._rectifyPath('F:/a/node_modules/b/node_modules/d/node_modules/e/f.js').path.should.equal('[a]/[b]/[d]/[e]/f.js');
      });
      return it("should return path when `node_modules` is not present", function() {
        return ParsedError.prototype._rectifyPath('a/b/c').path.should.equal('a/b/c');
      });
    });
  });

}).call(this);
